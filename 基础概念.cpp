//数据结构部分：重点掌握：指针    结构体   动态内存的分配和释放

//地址就是内存单元的编号 ： 地址线、控制线、数据线
//指针的本质是一个操作受限的非负整数
//指针就是地址，地址就是指针
//指针变量是存放内存单元地址的变量


//结构体；是用户根据实际需要自己定义的复合数据类型
//结构体变量不能加减乘除，但可以互相赋值
//普通结构体变量和结构体指针变量作为函数传参的问题
//
//
//




//了解概念： 数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构、抽象数据类型 
// 逻辑结构和存储结构两方面的含义和相互关系
// 简述逻辑结构的四种基本关系并画出他们的关系图
// 存储结构由哪两种基本的存储方法实现


// 1. 在数据结构中，从逻辑上可以把数据结构分成 ： 线性结构和非线性结构
// 2. 通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着： 
// 不仅数据元素所包含的数据项的个数要相同，而且相应数据项的类型要一致
// 3.一些表面上很不相同的数据可以有相同的逻辑结构
// 4.以下与数据的存储结构有关的术语：顺序队列，链表、链栈
// 5.线性结构：线性表、栈、队列、串 （1对1）
// 6.非线性结构： 树（一对多）、图 （多对多）


//ADT 抽象数据类型名{
//    数据对象：<数据对象的定义>
//    数据关系：<数据关系的定义>
//    基本操作：<基本操作的定义>
// }ADT 抽象数据类型名


/*
抽象数据类型（ADT）定义举例：Circle的定义
 AD T抽象数据类型名{
   Data
     数据对象的定义
     数据元素之间逻辑关系的定义
   Operation
     操作 1
       初始条件
       操作结果描述
     操作 2
       .....
     操作 n
       .....
 }ADT抽象数据类型名


ADT Circle{
  数据对象：D={r,x,y|r,x,y均为实数}
  数据关系：R={<r,x,y>|r是半径, <x,y>是圆心坐标}
  基本操作：
    Circle(&C,r,x,y)
            操作结果：构造一个圆
    double Area(C)
          初始条件：圆已存在
          操作结果：计算面积
    double Circumference(C)
          初始条件：圆已存在
          操作结果：计算周长

}ADT Circle
*/


/*
抽象数据类型（ADT）定义举例：复数的定义
 ADT 抽象数据类型名{
   Data
     数据对象的定义
     数据元素之间逻辑关系的定义
   Operation
     操作 1
       初始条件
       操作结果描述
     操作 2
       .....
     操作 n
       .....
 }ADT抽象数据类型名


ADT Complex{
 D={r1,r2|r1,r2均为实数}
 R={r1,r2>|r1是实部, r2是虚部}

assign(&C,v1,v2)
   初始条件：空的复数C已存在
   操作结果：构造复数C，r1，r2分别被赋以参数v1,v2的值
destroy(&C)
   初始条件：复数C已存在
   操作结果：复数C被销毁
GetReal(Z, &realPart)
   初始条件：复数已存在。操作结果：用realPart返回复数Z的实部值
Getlmag(Z,&ImagPart)
   初始条件：复数已存在。操作结果：用ImagPart返回复数Z的实部值
Add(z1,z2,&sum)
   初始条件：z1，z2是复数。操作结果：sum返回两个复数z1，z2的和
}ADT Complex
*/


/*
Void assign(Complex* A, float real, float imag) {
    A->realpart = real;    //实部赋值
    A->imagpart = imag;    //虚部赋值
}                          //End of assign()
void add(Complex* c, Complex A, Complex B) { // c=A+B
    c->realpart = A.realpart + B.realpart;   //实部相加
    c->imagpart = A.imagpart + B.imagpart;   //虚部相加
} //End of Add()
*/



//时间复杂度是由嵌套最深层语句的频度决定的
//算法中的基本操作的执行次数，为算法的时间复杂度

// 时间复杂度T(n)按数量级递增顺序为：
//（复杂度低） 常数阶 - 对数阶 - 线性阶 - 线性对数阶 - 平方阶 - 立方阶 - k次方阶 - 指数阶（复杂度高）
//有些算法的时间复杂度存在最好(1)、最坏(n)、平均(2/n)情况，考虑最坏的情况


//递归算法如何计算：递归次数*每次递归函数的次数

//用递归算出斐波那契 时间复杂度：2^n - 1


//时间复杂度不计算时间，计算大概的运算次数
//空间复杂度不计算空间，计算大概定义的变量个数


